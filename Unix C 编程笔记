//This is a new notebook about Unix/Linux C Programming

1.  局部变量：一定要初始化。在代码块执行完成后即被释放，若无初始化，收到执行环境，执行顺序等因素干扰，值的变化将不确定。 
    #include <stdio.h>

    void foo(void)
    {
	    int i;
	    printf("%d\n", i);
	    i = 777;
    }

    int main(void)
    {
	    foo();
	    foo();
	    return 0;
    }
    result: 127237371
            777
    两次结果并不一样，“看来”第二次按正常情况输出了。其实并非如此。
    第一、 两次解雇不一样说明i未初始化，确实将带来结果不一致的情况。
    第二、 第二次结果是777只是假象，并非局部变量也会分配内存空间。
    这里，请注意一句话：初值的变化将不确定，这并不代表不能值的变化不会出现某些特殊情况。
    原因是： 第二次赋值之前，系统发现程序中i并没有被初始化，而根据Linux C的运行规范，会在
             以执行的过程中寻找当前局部变量已存在的值，因此会在第二次执行时出现777。
    
2.  gdb常见指令表：
    
    backtrace(bt)   查看各级函数调用及参数
    finish          连续运行到当前函数返回为止，然后停下来等待命令
    frame(f) 帧编号 选择栈帧
    info(i) locals  查看当前栈帧局部变量的值
    list(l)         列出源代码，接着上次的位置往下列，每次列10行
    list行号        列出从第几行开始的源代码
    next(n)         执行下一条语句
    print(p)        打印表达式的值，通过表达式可以修改变量的值或者调用函数
    quit(q)         推出gdb调试环境
    set var         修改变量的值
    start           开始执行程序，停在main函数第一行语句前面等待命令
    step(s)         执行下一行语句，如果有函数调用则进入函数内部继续执行
